package proxyrelay

import (
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"
	"os"

	"github.com/hashicorp/yamux"
	"golang.org/x/sync/errgroup"
)

// Event holds the events that are generated by RunProxy.
type Event struct {
	Type string
	Data string
}

const (
	// TypeError signifies an error event with the error message stored in the Data attribute.
	TypeError = "error"
	// TypeRelayConnected is generated when RunProxy is started. The relay
	// connection's remote address is stored in the Data attribute.
	TypeRelayConnected = "relay connected"
	// TypeRelayDisconnected is generated when the relay connection is closed.
	// The Data attribute may contain a related error message.
	TypeRelayDisconnected = "relay disconnected"
	// TypeSOCKS5Active is generated when the SOCKS5 server is started. The Data
	// attribute is always empty.
	TypeSOCKS5Active = "SOCKS5 server active"
	// TypeSOCKS5Inactive is generated when the SOCKS5 server is stopped. The Data
	// attribute is always empty.
	TypeSOCKS5Inactive = "SOCKS5 server inactive"
)

// DefaultEventCallback prints all events to stdout except for error events,
// which are printed to stderr.
var DefaultEventCallback = func(e Event) {
	switch e.Type {
	case TypeError:
		fmt.Fprintf(os.Stderr, "error: %s\n", e.Data)
	case TypeRelayConnected:
		fmt.Printf("relay %s connected\n", e.Data)
	case TypeRelayDisconnected:
		fmt.Print("relay disconnected")
		if e.Data != "" {
			fmt.Print(": " + e.Data)
		}

		fmt.Println()
	case TypeSOCKS5Active:
		fmt.Println("SOCKS5 server active")
	case TypeSOCKS5Inactive:
		fmt.Println("SOCKS5 server inactive")
	default:
		fmt.Fprintf(os.Stderr, "unexpected event %q: %s\n", e.Type, e.Data)
	}
}

// RunProxy starts a SOCKS server on socks5listenAddr that tunnels all incoming
// connections through relayConn. The opposite site of the relayConn connection
// should be handled by RunRelay.
func RunProxy(ctx context.Context, relayConn net.Conn, socks5listenAddr string) (err error) {
	return RunProxyWithEventCallback(ctx, relayConn, socks5listenAddr, DefaultEventCallback)
}

// RunProxyWithEventCallback is like RunProxy but it allows to specify a custom
// event callback instead of DefaultEventCallback.
func RunProxyWithEventCallback(
	ctx context.Context, relayConn net.Conn, socks5ListenAddr string, callback func(Event),
) error {
	if callback != nil {
		callback(Event{Type: TypeRelayConnected, Data: asIP(relayConn.RemoteAddr()).String()})
	}

	err := handleRelayConnection(ctx, relayConn, socks5ListenAddr, callback)
	if errors.Is(err, net.ErrClosed) {
		err = nil
	}

	if callback != nil {
		data := ""
		if err != nil {
			data = err.Error()
		}

		callback(Event{Type: TypeRelayDisconnected, Data: data})
	}

	return err
}

func handleRelayConnection(ctx context.Context, relayConn net.Conn, proxyAddr string, callback func(Event)) error {
	go func() {
		<-ctx.Done()

		_ = relayConn.Close()
	}()

	if callback != nil {
		callback(Event{Type: TypeRelayConnected, Data: asIP(relayConn.RemoteAddr()).String()})
	}

	client, err := yamux.Client(relayConn, yamuxCfg())
	if err != nil {
		return fmt.Errorf("initialize multiplexer: %w", err)
	}

	// we use the first connection to receive socks-related errors from the relay
	errConn, err := client.Open()
	if err != nil {
		return fmt.Errorf("open error notification connection: %w", err)
	}

	// display the errors in the UI
	go handleErrorNotificationConnection(errConn, callback)

	err = startLocalProxyServer(proxyAddr, client, callback)
	if err != nil {
		return fmt.Errorf("proxy: %w", err)
	}

	return nil
}

func handleErrorNotificationConnection(conn net.Conn, callback func(Event)) {
	for {
		lengthBytes := make([]byte, 4)

		_, err := conn.Read(lengthBytes)
		if errors.Is(err, io.EOF) {
			return
		} else if err != nil {
			if callback != nil {
				callback(Event{
					Type: TypeError,
					Data: fmt.Sprintf("read message length from error notification connection: %v", err),
				})
			}

			return
		}

		msg := make([]byte, binary.BigEndian.Uint32(lengthBytes))

		_, err = conn.Read(msg)
		if err != nil {
			if callback != nil {
				callback(Event{Type: TypeError, Data: fmt.Sprintf("read message from error notification connection: %v", err)})
			}

			return
		}

		if callback != nil {
			callback(Event{Type: TypeError, Data: string(msg)})
		}
	}
}

func startLocalProxyServer(proxyAddr string, sess *yamux.Session, callback func(Event)) error {
	proxyListener, err := net.Listen("tcp", proxyAddr)
	if err != nil {
		return fmt.Errorf("listen for relay connection: %w", err)
	}

	defer proxyListener.Close() //nolint:errcheck

	if callback != nil {
		callback(Event{Type: TypeSOCKS5Active})
		defer callback(Event{Type: TypeSOCKS5Inactive})
	}

	var closedBecausePayloadDisconnected bool

	go func() {
		<-sess.CloseChan()

		closedBecausePayloadDisconnected = true

		err := proxyListener.Close()
		if err != nil && callback != nil {
			callback(Event{Type: TypeError, Data: fmt.Sprintf("socks5 close: %v", err)})
		}
	}()

	for {
		conn, err := proxyListener.Accept()
		if err != nil {
			if closedBecausePayloadDisconnected {
				return nil
			}

			return fmt.Errorf("accept socks5 connection: %w", err)
		}

		go func() {
			err := handleLocalProxyConn(conn, sess)
			if err != nil && callback != nil {
				callback(Event{Type: TypeError, Data: fmt.Sprintf("handling socks5 connection: %v", err)})
			}
		}()
	}
}

func handleLocalProxyConn(conn net.Conn, sess *yamux.Session) error {
	yamuxConn, err := sess.Open()
	if err != nil {
		return fmt.Errorf("open multiplexed connection: %w", err)
	}

	var eg errgroup.Group

	eg.Go(func() error {
		_, err := io.Copy(yamuxConn, conn)
		if err != nil {
			return fmt.Errorf("proxy->relay: %w", err)
		}

		return nil
	})

	eg.Go(func() error {
		_, err := io.Copy(conn, yamuxConn)
		if err != nil {
			return fmt.Errorf("relay->proxy: %w", err)
		}

		return nil
	})

	return eg.Wait()
}

func asIP(addr net.Addr) net.IP {
	switch a := addr.(type) {
	case *net.TCPAddr:
		return a.IP
	case *net.UDPAddr:
		return a.IP
	default:
		panic(fmt.Sprintf("unexpected address type: %T", a))
	}
}
